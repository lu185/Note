# 葵花宝典

## `Java`基础部分



### 一个`Java`源文件中是否可以包括多个类(不是内部类)？有什么限制？

可以有多个类，但只能有一个 `public` 类，并且 `public` 的类名必须与文件名一致



### `Java`中有没有`goto`

`goto`时`Java`中的保留字，`JVM`并没有对其进行实现



### 说说`&`和`&&`的区别

`&`和`&&`都可以作为 逻辑与 (`and`) 的运算符，当 运算符 的两边的表达式 都为`true`时，整个运算的结果才为`true`，只要有一方为`false`，则整个表达式为`false`

`&&`具有短路的功能，即如果第一个表达式的值为`false`，则不计算第二个表达式，`&`不管第一个表达是的值是`true`或`false`，都会执行第二个表达式

```java
// 使用 && 不会抛出异常
// 使用 & 则会抛出 空指针 异常
if( str!=null && str.equals("") ){ ... }

// 使用 && i的值不会自增
// 使用 & i的值会自增
if( bl && ++i ){ System.out.println(i) }
```



### `switch`语句能否作用在`byte`上，能否作用在`long`上，及`String`上

在`switch(表达式)`中，表达式只能是一个整数表达式或者枚举常量，整数类型可以是`int`基本类型或`Integer`包装类型，因为`byte`，`short`，`char`都可以隐式转换为`int`,所以这些数据类型及包装类型也是可以的，显然`long`和`String`类型都不符合`switch`的语法规定，并且并不能隐式的转换成`int`类型，所有它们并不能作用于`switch`上



### `short number=1`，`number=number+1`有没有错，`number+=1`有没有错

`number=number+1`有错，由于`number+1`运算时会自动的提升表达式的类型，所以结果是`int`类型，再赋值给`short`类型的`number`时，编译器将报告需要强制类型转换的错误

`number+=1`没错，由于`+=`是`Java`语言规定的运算符，`Java`编译器会对其进行特殊的处理，因此可以正确编译



### `char`类型中能不能存储一个中文汉字，为什么？

`char`类型变量使用来存储`Unicode`编码的字符的，`Unicode`编码字符集中包含了中文字符，所以，`char`类型变量中可以存储中文汉字，不过，如果某个特殊的汉字没有被包含在`Unicode`中，那么，这个字符就不能存储在`char`类型中。（`Unicode`编码占用两个字节，所以`char`类型变量也占用两个字节）



### 用最有效率的方法算出 `2*8=?`

最有效率的方法是：`2<<3`          `2<<3 = 2 * 2^3 = 2 * 8`

将一个数左移3位，就相当于这个数乘以2的3次方，那么，一个数乘以8，只需要将这个数左移3位即可，而且`cpu`直接支持位运算，效率最高。



### 使用`final`关键字修饰一个变量时，是引用不变，还是引用的对象不能变

使用`final`关键字修饰一个变量时，是指引用的变量不能变，引用变量指向的对象中的内容是可以改变的

```java
final StringBuffer str = new StringBuffer("hello ");
str.append("world");       // 这个是可以的
str = new StringBuffer("");					// 报错
```



### `==`和`equals`方法究竟有什么区别

`==`操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本数据类型的数据或两个引用变量是否相等，只能用`==`操作符

`equals`方法用于比较两个独立对象的内容是否相同。就好比去比较两个人的长相是否相同，他比较的两个对象是独立的。

```java
// String 中的 equals 方法解析
public boolean equals(Object anObject) {
    
    // 如果当前对象 等于 anObject  返回 true,
    // 即 多个引用指向同一个对象
    if (this == anObject) {
        return true;
    }
    
    // 用来比较的对象是否是个字符串
    if (anObject instanceof String) {
        // 强制类型转换 
        String anotherString = (String)anObject;
        // this 中的 字符串长度
        int n = value.length; 
        
        // 判断两个字符串的长度是否相同
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            
            // 循环每一个字符
            while (n-- != 0) {
                // 每个字符是否相同
                if (v1[i] != v2[i])
                    // 不同返回 false
                    return false;
                i++;
            }
          	// 完全相同返回 true；
            return true;
        }
    }
    return false;
}
```



### 静态变量于实例变量的区别

在语法定义上的区别：静态变量前面要加`static`关键字修饰，而实例变量则不需要

在程序运行时的区别：实例变量属于某个对象的属性，所以必须创建了实例对象，其中的实例变量才会被分配内存空间，才能使用这个实例变量，静态变量不属于某个实例对象，而是属于类，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配内存空间，静态变量就可以被使用了。



### 是否可以从一个`static`的方法中对一个非`static`方法进行调用

不可以，因为非`static`方法是与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而非`static`方法调用时不需要创建对象，可以直接调用，也就是说，当一个`static`方法被调用时，可能还没有创建任何实例对象，如果从一个`static`方法中对非`static`方法发起调用，那么非`static`方法是关联到那个对象上呢，这个逻辑不能成立，所以，不可以从一个`static`的方法中对一个非`static`方法进行调用



### `Integer`和`int`的区别

`int`是`Java`中的八种基本数据类型之一。`Java`为每个原始数据类型提供了封装类，`Integer`是`Java`为`int`提供的封装类。`int`的默认值为0，而`Integer`的默认值为null，即`Integer`可以区分出0和未赋值的状态。`int`则无法表达储未赋值的情况，例如，要表达出没有参加考试的和考试成绩为0的区别，只能使用`Integer`。



### `Math.round(11.5)`等于多少？`Math.round(-11.5)`等于多少？

`Math`类中提供了三个于取整有关的方法：`ceil`向上取整，`floor`向下取整，`round`四舍五入，

`round`的算法是将原来的数加0.5然后向下取整，所以`Math.round(11.5)`等于12,`Math.round(-11.5)`等于11



### `public`，`private`，`protected`，以及不写时的区别

不写时的默认修饰符是`friendly`

| 作用域      | 当前类 | 当前包 | 子孙类 | 其他包 |
| ----------- | :----: | :----: | :----: | :----: |
| `public`    |   √    |   √    |   √    |   √    |
| `protected` |   √    |   √    |   √    |        |
| `friendy`   |   √    |   √    |        |        |
| `private`   |   √    |        |        |        |



### `Overload`和`Override`的区别，`Overload`的方法是否可以改返回值的类型

`Overload`是重载的意思，`Override`是重写的意思

重载表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表的参数类型，参数顺序，参数个数，各不相同

重写表示子类中的方法可以与父类中的某个方法的名称，返回值，参数完全相同，通过子类创建的对象调用这个方法时，将调用子类中定义的这个方法，这相当于把父类中定义的那个完全相同的方法给覆盖了。如果父类的方法是`private`类型，那么子类就不存在覆盖的限制，相当于子类中增加了一个全新的方法



### 构造器`Constructor`是否可以被`Override`

构造器`Constructor`不能被继承，因此不能重写，但是可以被重载



### 接口是否可以继承接口，抽象类是否可以实现接口，抽象类是否可以继承具体类，抽象类中是否可以有`main`方法。

接口可以实现接口，抽象类可以实现接口，抽象类可以继承具体类，抽象类中可以具有`main`方法、



### 写`clone()`方法时，通常都有一行代码，是什么

`clone`有缺省行为，`super.clone()`；因为首先要把父类中的成员复制到位，然后才能复制自己的成员



### 面向对象的特征有哪些方面

面向对象的特征有 封装，抽象，继承，多态等四个主要特征

封装：面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法定义，方法可以访问对象中的属性。封装要把握一个原则：把对同一事物进行操作的方法和相关的方法放在一个类中，把方法和它操作的数据放在同一个类中。

抽象：抽象就是找出一些事物的相似和共性之处，然后将这些事物的归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题无关的那些方面，将注意力集中与当前目标有关的方面。

继承：在定义和实现一个类的时候，可以在一个已经存在的类的基础上来进行，把这个已经存在的类中所定义的内容作为自己的内容，并加入若干的新的内容，或修改原来的方法来满足现在的需求，这就是继承，继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性

多态：父类的引用指向子类的对象



### `Java`中的多态的实现机制是什么

实现的机制靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期间才动态绑定的，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。



### `abstract class`和`interface`的区别

含有`abstract`修饰符的`class`类即为抽象类，抽象类不能创建实例对象，含有`abstract`修饰符的方法必须是抽象类的方法，即抽象方法，抽象类的方法不必是抽象方法，抽象类中的抽象方法必须在具体的子类中实现，所以不能有抽象构造方法和抽象静态方法，如果抽象类的子类没有实现所有的抽象方法，那么，子类也必须定义为抽象类

`interface`接口可以说成是抽象类的一种特例，接口中的所有方法必须是抽象的，接口中的方法默认为`public abstract`类型，接口中的成员变量类型默认为`public static final`。

两者的区别：

1. 抽象类可以有构造方法，接口不能有
2. 抽象类可以有普通的成员变量，接口中不能有
3. 抽象类可以包含非抽象的普通方法，接口中的所有方法必须是抽象的
4. 抽象类的抽象方法的访问修饰符可以是`public` ，`protected`和默认的`friendy`，但接口中的方法只能是`public`类型的，并默认为`public abstract`类型
5. 抽象类中可以有静态方法法，接口不能有
6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的成员变量只能是`public static final`类型，并且默认为`public static final`类型。
7. 一个类可以实现多个接口，但只能继承一个抽象类



### 抽象方法是否可以被`static`修饰，是否可以被`native`修饰，是否可以被`synchronized`修饰

抽象方法不可以被`static`修饰，因为抽象方法是要被子类实现的，而被`static`修饰的方法和子类扯不上关系

`native`修饰的方法表示该方法要依赖其他编程语言实现功能。不存在被子类实现的问题，所以他不能被抽象。

关于`synchronized`与`abstract`合用的问题，我觉得不行，因为在我几年的学习和开发实践中，从来没有见过这种情况，并且我觉得`synhronized`应该是作用在一个具体的方法上才有意义，而且，方法上的`synchronized`同步所使用的同步锁是`this`，而抽象方法上无法确定`this`是什么。



### `String`是最基本的数据类型吗

`Java`的八大基本类型是`byte`,`shot`,`int`,`long`,`float`,`double`,`boolean`,`char`

`String`是个被`final`修饰的类，所以不能被继承，不能被修改，即断子绝孙类。为了提高效率，节省空间，我们应该使用`StringBuffer`类



### `String s="hello ";  s=s+"world"`，原始的`String`对象中的内容到底变了没有

没有。因为`String`被设计成不可变类，所以他的所有对象都是不可变对象。`s`最初指向了值为`hello`的地址，`S`加上`word`后的值为`hello world`，这时`s`这个引用变量的值又指向了`hello world`的地址，所以原来的`String`中的内容没有变，只是`s`指向了新的地址



### 是否可以继承`String`类

不可以，`String` 是一个被`final`修饰的类，不能被继承，修改，即 断子绝孙类



### `String s = new String("xyz");`创建了几个字符串对象，二者的区别

两个。一个是静态区的`"xyz"`，一个是用`new`创建在堆上的对象。



### `String`和`StringBuffer`的区别

`Java`平台提供了两个类`String`和`StringBuffer`，他们可以用来存储和操作字符串，即包含多个字符的字符数据，这个`String`类提供类数值不可改变的字符串，而这个`StringBuffer`类提供了字符串修改，当你知道字符数据需要改变的时候你就可以使用`StringBuffer`来动态构造字符数据，另外，`String`实现了`equals`方法，`new String("abc").equals(new String("abc"));`的结果为`true`,而`StringBuffer`没有实现`equals`方法，所以，`new StringBuffer("abc").equals(new StringBuffer("abc"))`的结果为`false`。



### 数组有没有`length()`方法，`String`有没有`length()`方法

数组没有`length()`方法，有`length`属性，`String`没有`length（）`方法



### `String s = "a"+"b"+"c"+"d"；`一共创建了多少个方法

```java
String s1 = "a";
String s2 = s1+"b";
String s3 = "a"+"b";

System.out.println( s2 == "ab" );     // false
System.out.println( s3 == "ab" );	  // true
```

第一条语句打印的结果为`false`，第二条语句的打印结果为`true`，这说明`Java`编译时可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个常量相连的一个结果。所以对于语句`String s = "a"+"b"+"c"+"d";`来说，最终只创建了一个对象。



### `try{}`里有一个`retrun`,那么紧跟在这个`try`后的`finally{}`里的代码会不会得到执行，什么时候被执行，在`return`前还是后

有如下代码：

```java
public class Test {
    public static void main(String[] args) {
        System.out.println("return "+run());
    }
    static int run(){
        int x = 0;
        try {
            x = 1;
            System.out.println("try "+x);
            return x;
        }finally {
            x++;
            System.out.println("finally "+x);
        }
    }
}
```

结果

```
try 1
finally 2
return 1
```



结果很明显，`finally{}`里的代码会得到执行，代码会在`return`返回之后处理`findally`中的代码。



### 如下程序的运行结果是多少

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(run());
    }
    static int run(){
        try {
            return 1;
        }finally {
            return 2;
        }
    }
}
```

结果为`2`，底层原理:`return`不会立刻让方法返回结果，会把返回的结果放在函数栈中，等到`finally`执行完成之后，才会把真正的结果返回。



### `final`，`finally`，`finalize`的区别

`final`用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。

`finally`是异常处理语句结构的一部分，表示总是执行。

`finalize`是`Object`类中的方法，在垃圾收集器执行的时候要被回收的对象会调用此方法。`JVM`不保证此方法总被调用



### 运行时异常与一般异常有何异同？

异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，`Java`编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。



### `Error`和`Exception`有什么区别

`Error`：表示恢复不是不可能但是很困难的情况下的一种严重问题，比如说内存溢出，不可能指望程序处理这样的情况。

`Exception`：表示一种设计或实现的问题，他表示如果程序运行正常，从不会发生的情况



### `Java`中的异常处理机制的简单原理和应用

异常是指`Java`程序运行时所发生的非正常情况，`Java`使用面向对象的方式来处理异常，它把程序中发生的所有异常分别封装到每一个类中，该类的对象包含异常的信息。

`Java`对异常进行了分类，不同类型的异常用不同的`Java`类来表示，所有异常类的根类是`java.lang.Throwable`，`Throwable`下面又派生出两个子类：`Error`和`Exception`。

`Error`：表示程序本身无法克服和恢复的一种严重问题，程序只有死的份了。例如：内存溢出，线程死锁等问题。

`Exception`：表示程序本身还可以克服和恢复。其中又分为系统异常和普通异常。

- 系统异常：是软件本身的缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，用户无法克服和恢复这种问题，但是在这种问题下还可以让软件系统继续运行或者让软件死掉。例如：数组下标越界，空指针异常，类转换异常。
- 普通异常：是运行环境的变化或异常所导致的问题，是用户可以克服的问题，例如：网络断线，硬盘空间不够，发生这样的异常之后程序不应该死掉。

`Java`为异常提供了不同的解决方案，编译器强制普通异常必须`try{}catch{}`处理或用`throws`声明继续抛给上层调用方法处理，所以普通异常也被称为`checked`异常，而系统异常可以处理也可以不处理，所以不强制使用`try{}catch{}`和`throws`处理，所以系统异常也被称为`unchecked`异常。




### 请写出五个最常见的运行时异常

| 异常                             | 描述             |
| -------------------------------- | ---------------- |
| `NullPointerException`           | 空指针异常       |
| `ClassNotFoundException`         | 类未定义异常     |
| `ArrayIndexOutOfBoundsException` | 数组下标越界异常 |
| `ClassCastException`             | 类转换异常       |
| `ArithmeticException`            | 除数为0异常      |



### `sleep()`和`wait()`的区别

`sleep()`就是让正在执行的线程主动让出`cpu`，`cpu`区执行其他线程，在`sleep()`指定的时间过后，`cpu`才会回到这个线程上继续往下执行，如果当线程进入了同步锁，`sleep()`方法并不会释放锁，即使当前线程使用`sleep()`方法让出了`cpu`，但其他被同步锁挡住了的线程也无法执行。

`wait()`是指在一个已经进入了同步锁的线程内，让自己暂时的让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有当其他线程调用了`notify()`方法(`notify()`方法并不释放锁，只是告诉调用过`wait()`方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没有释放)，调用`wait()`方法的线程就会解除`wait()`状态和程序可以再次得到锁后继续向下运行。



### 同步和异步有何异同，在什么情况下分别使用他们？

如果数据将在线程间共享，例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序让等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。



### 多线程有几种实现方法，同步有几种实现方法

多线程有两种实现方法，分别是继承`Thread`类和实现`Runnable`接口。

同步有两种实现方法，分别是`synchronized`，`wate()`和`notify()`



### 启动一个线程使用`run()`还是`start()`

启动一个线程调用`start()`方法，使线程进入就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，`run()`方法是该线程所关联的执行代码。



### 当一个线程进入一个对象的一个`synchronized`方法后，其他线程是否可进入此对象的其他方法

分情况：

- 其他方法前是否加了`synchronized`关键字，如果没加，则能。
- 如果这个方法内部调用了`wait()`方法，则可以进入其他`synchronized`方法。
- 如果其他方法都加了`shnchronized`关键字，并且内部没有调用`wait()`，则不能。
- 如果其他方法是`static`，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是`this`。



### 线程的基本概念，线程的基本状态以及状态之间的管理

一个程序中可以有多条线程同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，既可以有多段程序代码同时运行，每个程序至少都有一个线程，即`main`方法执行的那个线程。如果只是一个`cpu`，它怎么能够同时执行多段程序呢？这是从宏观上来看的，`cpu`一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a，b在同时执行。

线程的状态：就绪，运行，`synchronize`阻塞，`wate()`和`sleep()`挂起，结束。( `wate()`必须在`synchronize`内部调用 )

调用线程的`start()`方法后，线程进入就绪状态，线程调度系统将就绪状态的线程转换为运行状态，遇到`synchronize`语句时，由运行状态转换为阻塞状态，当`synchronize`获得锁后，由阻塞状态转为运行状态，在这种情况下可以调用`wait()`方法转换为挂起状态，当线程关联的代码执行完成后，线程变为结束状态。



### 简述`synchronized`和`java.util.concurrent.locks.Lock`的异同

相同点：`Lock`能完成`synchronized`所实现的所有功能。

不同点：`Lock`有比`synchronized`更精确的线程语义和更好的性能。`synchronized`会自动释放锁，而`Lock`要手动释放，并且必须在`finally`语句块中释放，`Lock`还有更强大的功能，例如，它的`tryLock()`方法可以用非阻塞的方式去拿锁。



### 介绍`Collection`框架的结构



### `Collection`框架中完成比较功能要实现什么接口

`comparable`/`comparator`



### `ArrayList`和`Vector`的区别

它们都实现了`List`接口(`List`接口继承于`Collection`接口)，他们都是有序集合，即：存储在这两个集合中的元素都是有顺序的，相当于是一种动态数组，可以按照下标取出相应的元素，并且元素是允许重复的。区别：

同步性：`Vector`的线程是安全的，即它的方法之间的线程是同步的，而`ArrayList`的线程是不安全的，他的方法之间的线程是不同步的。如果只有一个线程会访问到集合，那最好是使用`ArrayList`，因为它不考虑线程安全，效率会高些，如果有多个线程会访问到集合，那最好使用`Vector`，因为不需要我们再去考虑和编写线程安全的代码。

数据增长：`ArrayList`与`Vector`都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加`ArrayList`和`Vector`的存储空间，每次要增加存储空间时，不是只增加了一个存储单元，而是增加了多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡，`Vector`默认增长的为原来的两倍，而`ArrayList`的增长策略在文档中没有明确的规定（从源代码中解读到的是增长为原来的1.5倍），`ArrayList`与`Vector`都可以设置初始的空间大小，`Vector`还可以设置增长的空间，而`ArrayList`没有设置可以增长空间的方法。



### `HashMap`和`Hashtable`的区别

`HashMap`是`Hashtable`的轻量级实现，他们都完成了`Map`的接口，主要区别在于`HashMap`允许`Key`为空，由于非线程安全，在只有一个线程访问的情况下效率要高于`Hashtable`。

`HashMap`把`Hashtable`的`contains`方法去掉了，改成了`containsKey`和`containsValue`，因为`contains`方法容易让人误解。

`Hashtable`继承自`Dictionary`类，而`HashMap`是`Java1.2`引进的`Map`接口的一个实现。最大的不同是，`Hashtable`的方法是线程是安全的，而`HashMap`不是，在多个线程访问`Hashtable`时，不需要自己为它的方法实现同步，而`HashMap`的就必须方法同步。

`Hashtable`和`HashMap`采用的`hash\rehash`算法大概都一样，所以性能不会有很大的差异。

就`HashMap`和`Hashtable`主要从三方面来说：

1. 历史原因：`Hashtable`是基于陈旧的`Dictionary`类的，`HashMap`是`Java1.2`引进的Map接口的一个实现
2. 同步性：`Hashtable`是线程安全的，是同步的，而`HashMap`是线程不安全的，是不同步的。
3. 值：`HashMap`可以将空值作用为`key`或`value`



### `List`和`Map`的区别

一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，`List`中存储的数据是有序的，并且允许重复，`Map`中存储的数据是没有顺序的，其键是不能重复的，它的值是可以允许重复的。



### `List`，`Set`，`Map`是否继承自`Collection`接口

`List`，`Set`是，`Map`不是



### `List`，`Map`，`Set`三个接口存储数据时，各有什么特点

首先，`List`与`Set`具有相似性，它们都是单列元素的集合，所以他们都有一个共同的父接口，叫`Collection`，`Set`里面不允许有重复的元素，会对数据进行排序，`Set`的`add()`方法有一个`boolean`的返回值，当集合中没有某个元素时，此时`add()`方法可以成功的加入该元素，返回值为`true`，当集合含有某个元素时，此时`add()`方法无法加入该元素，返回值为`false`，`Set`取元素时，没法说取第几个，只能以`Iterator`接口取得所有的元素，再逐一遍历各个元素。

`List`表示有先后顺序的集合，当调用`add()`方法的时候，元素会依次往后添加，也可以在`add()`中指定下标，就可以指定当前元素在集合中的位置，一个对象可以反复存储进集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被多次添加时，即相当于集合中有多个索引指向了这个对象，`List`除了可以以`Iterator`接口取得所有的元素，再逐一遍历各个元素之外，还可以调用`get()`方法来说明取第几个。

`Map`与`List`和`Set`不同，他是双列的集合，其中有`put()`方法，每次存储时要存储一对`key/value`，不能存储重复的`key`，会将之前的覆盖掉，取值则是根据`key`获得相应的`value`，即使用`get()`方法获取`value`值，另外，也可以获取所有`value`的集合，还可以获取`key`和`value`组合成的`Map.entity`对象的集合。

`List`以特定次序来持有元素，可以重复元素。`Set`无法拥有重复元素，内部排序。`Map`保存`key-value`值，`value`可多值。

`HashSet`按照`HashCode`值的某种运算方式进行存储，而不是直接按照`HashCode`值的大小进行存储。

同一个对象可以在`Vector`中加入多次，往集合里添加元素，相当于集合里用一根绳子连接到了目标对象，往`HashSet`中却添加不了多次。



### 说说`ArrayList`，`Vector`，`LinkedList`的存储性能和特性

`ArrayList`和`Vector`都是使用数组的方式存储数据，此数组元素数大于实际存储的数据以便增加和存储的元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据块而插入数据慢，`Vector`由于使用了`synchronized`方法（线程安全），通常性能上比`ArrayList`差，`LinkedList`使用了双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据是只需要记录本项的前后项即可，所以插入速度比较块。



### 去掉一个`Vector`集合中的元素

```java
Vector vector = new Vector();
// add Data;
HashSet set = new HashSet(vector);
```



### `Collection`和`Collections`的区别

`Collection`是集合类的上级接口，继承与他的接口主要有`Set`和`List`

`Collecctions`是针对集合类的一个帮助类，它提供一系列静态方法实现对各种集合的搜索，排序，线程安全化的操作。



### `Set`里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用`==`还是`equals()`？他们有何区别？

`Set`里的元素时不能重复的，元素重复与否是使用`equals()`方法进行判断的。`equals()`和`==`决定引用值是否指向同一对象，`equals()`在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回其值。



### 你所知道的集合类有哪些？主要方法？

最常用的集合类是`List`和`Map`，`List`的具体实现包括`ArrayList`和`Vector`，它们是可变大小的列表，比较适合构建，存储和操作任何类型对象的元素列表。`List`适用于按数值索引访问元素的情形。`Map`提供了一个更通用的元素存储方法。`Map`集合类采用键值对的方式存储数据。

| 类            | 方法                     |
| ------------- | ------------------------ |
| `List`，`Set` | `add()`添加，`get()`获取 |
| `Map`         | `put()`添加              |



### 两个对象值相同，但却可以有不同的`HashCode`，这句话对不对？

对。如果对象要保存在`HashSet`或`HashMap`中，它们的`equals`相等，那么，它们的`HashCode`值必须相等。

如果不是要保存在`HashSet`或`HashMap`，则与`HashCode`没有什么关系了，这时候`HashCode`不等是可以的，例如`ArrayList`存储的对象就不用实现`HashCode`，当然，我们没有理由不实现，通常都会去实现的。



### `ThreeSet`里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的`compareTo`方法，还是使用的子类的`compareTo`方法，还是抛异常

应该是没有针对问题的确切的答案，当前的add方法放入的是那个对象，就调用哪个对象的`compareTo`方法，至于这个`compareTo`方法怎么做，就看当前这个对象的类中是如何编写这个方法的。



### 说出一些常用的类，包，接口，请说五个

常用类

| 类名               | 描述         |
| ------------------ | ------------ |
| `java.lang.Object` | 根类         |
| `java.lang.String` | 字符串       |
| `java.lang.System` | 标准输入输出 |
| `java.io.file`     | 文件系统     |
| `java.util.Date`   | 日期         |

常用包

| 包名            | 描述               |
| --------------- | ------------------ |
| `java.lang`     | 核心包             |
| `java.io`       | 文件               |
| `java.util`     | 工具包             |
| `java.SQL`      | 数据库             |
| `javax.servlet` | `Java Web`应用容器 |

常用接口

| 接口名                 | 描述     |
| ---------------------- | -------- |
| `java.util.List`       | 集合接口 |
| `java.util.Map`        | 集合接口 |
| `java.util.Set`        | 集合接口 |
| `java.lang.Runnable`   | 多线程   |
| `java.io.Serializable` | 序列化   |



### `Java`中有几种类型的流？`JDK`为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？

字节流，字符流，字节流继承于`InputStream`，`OutputStream`，字符流继承于`InputStreamReader`，`OutputStreamWirter`。在`java.io`包还有许多其他的流，主要是为了提高性能和使用方便



### 字节流和字符流的区别

要把一片二进制数据据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为`IO`流，对应的抽象类为`InputStream`和`OutputStream`，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。

在应用中，将一段文本输出去或读进来，底层使用使用的是字节流，计算机中的一切的最终形式都是二进制的字节形式存在的。对于中文的这些字符，首先要得到其对应的字节，然后将字节写入到输出流，读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，作者专门提供了字符流的包装类。

底层设备永远只直接收字节数据，有时候要写字符串到底层设备，需要将字符串转换成字节在进行写入，字符流是字节流的包装，字符流规则是直接接受字符串，它内部将字符串转换成字节，再写入底层设备，这为我们向`IO`设备写入或读取字符串提供了一点点方便。

字符流向字节转换的时，要注意编码的问题，因为字符串转成字节数组。其实是转成该字符的某种编码的字节形式，读取也是反之的道理。



### 什么是`Java`序列化，如何实现`Java`序列化？或者请解释`Serializable`接口的作用。

我们有时候要将一个`Java`对象变成字节流的形式传出去或者从一个字节流中恢复成一个`Java`对象，例如，要将`Java`对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个`Java`对象变成某个格式的字节流再传输，但是，`jre`本身就提供了这种支持，我们可以调用`OutputStream`的`writeObject`方法来做，如果让`Java`帮我们来做，要被传输的对象必须实现`Serializable`接口，这样，`javac`编译时就会进行特殊处理，编译的类才可以被`writeObject`方法来操作，  这就是所谓的序列化，需要被序列化的类必须实现`Serializable`接口，该接口是一个`mini`接口，其中没有要实现的方法，`implements Serializable`只是为了标注该对象可以被序列化。

例如，在`web`开发中，如果对象被保存在了`Session`中，`tomcat`在重启时要把`Session`对象序列化到硬盘，这个对象就必须实现`Serializable`接口，如果对象要经过分布式系统进行网络传输或者通过`rmi`等远程调用，这就需要在网络上传输对象，被传输的对象就必须实现`Serializable`接口。



### 描述一下`JVM`加载`class`文件的原理机制？

`JVM`中类的装载是由`ClassLoader`和它的子类来实现的，`Java ClassLoader`是一个重要的`Java`运行时系统组件。他负责在运行时查找和装入类文件的类。



### `heap`和`stack`有什么区别

`Java`的内存分为两类，一类是栈内存，一类是堆内存，栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储在这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。

堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用`new`创建的对象都放在堆里，所以，他不会随方法的结束而消失，方法中的局部变量使用`final`修饰后，放在堆中，而不是栈中。



### `GC`是什么？为什么要有`GC`?

`GC`是垃圾回收的意思（`Gabage Collection`），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，`Java`提供的`GC`功能可以有动态监测对象是否超过作用域而达到自动回收内存的目的，`Java`语言没有提供释放已分配内存的操作方法。



### 垃圾回收的优点和原理，并考虑两种回收机制

`Java`语言中一个显著的特点就是引入了垃圾回收机制，使`C++`程序员最头疼的内存管理的问题迎刃而解，它使得`Java`程序员在编写程序的时候不再需要考虑内存管理，由于有个垃圾回收机制，`Java`中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”，垃圾回收可以有效的防止内存泄漏，有效的使用可以利用的内存，垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收，回收机制又分为待复制垃圾回收和标记垃圾回收，增量垃圾回收。



### 垃圾回收的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收。

对于`GC`来说，当程序员创建对象时，`GC`就开始监控这个对象的地址，大小以及使用情况，通常，`GC`采用有向图的方式记录和管理堆（`heap`）中所有的对象，通过这种方式确定哪些对象时可达的，哪些对象是“不可达的”，当`GC`确定一些对象为“不可达”时，`GC`就用责任回收这些内存空间，程序员可以手动执行`System.gc()`，通知`GC`运行，但是`Java`语言的规范并不保证`GC`一定会执行。



### `Java`中会存在内存泄漏吗？

所谓内存泄漏就是指一个不再被程序员使用的对象或变量一直被占据内存中，`Java`中有垃圾回收机制，他可以保证一对象不再被引用的时候，及对象编程了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉，由于`Java`使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要他们和根进程不可达的，那么`GC`也是可以回收他们的。



### 能不能自己写一个类，也叫`java.lang.String`?

可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载`jre.jar`包中的那个`java.lang.String`。由于`tomcat`的`web`应用程序中，都是由`webapp`自己的类加载器先自己加载`WEB-INF/classess`目录中的类，然后委托上级的类加载器加载，如果我们在`tomcat`的`web`应用程序中写一个`java.lang.String`，这时候`Servlet`程序加载的就是我们自己写的`java.lang.String`，但是这么干就会很多潜在的问题，原来所有用来`java.lang.String`类的都将出现问题。 







## `Java Web`

### `Tomcat`的优化经验

去掉对`web.xml`的监视，把`jsp`提前编译成`Servlet`。有富余的内存的情况下，加大`Tomcat`对`JVM`内存的使用



### `HTTP`的`GET`请求与`POST`请求的区别

`GET`和`POST`都是向服务器提交数据，并且都会从服务器中获取数据。区别在于：

- 传送方式：`GET`通过地址栏传输，`POST`通过报文传输。
- 传送长度：`GET`参数有长度限制（受限于`URL`的长度），而`POST`无限制。



### 解释一下什么是`Servlet`

`Servlet`是运行在`Web`服务器或应用服务器上的程序，他是作为来自`Web`浏览器或其他`Http`服务器上的数据库和应用程序之间的中间层。



### 说一说`Servlet`的生命周期

`Servlet`有良好的生存期定义，包括加载和实例化，初始化，处理请求以及服务结束，这个生存期由`javax.servlet.Servlet`接口的`init`，`service`，`destroy`方法表达。

`Servlet`被服务器实例化后，容器运行其`init`方法，请求到达时运行其`service`方法，`service`方法自动派遣运行与请求对应的`doXXX`方法（`doGet`，`doPost`）等，当服务器决定将实例销毁的时候调用`destroy`方法。

`Web`容器加载`Servlet`，生命周期开始，通过调用`Servlet`的`init()`方法进行`Servlet`的初始化，通过调用`service()`方法实现，根据请求的不同调用不同的`do***()`方法，结束服务，`Web`容器调用`Servlet`的`destroy()`方法.



### `Servlet`的基本架构

```java
public class ServletName extends HttpServlet{
    public void doGet( 
        HttpServletRequest request, 
        HttpServletResponse response ) throws ServletException, IOException{
        
    }
    
    public void doPost( 
        HttpServletRequest request, 
        HttpServletResponse response ) throws ServletException, IOException{
        
    }
}
```



### `Servlet API`中的`forward()`和`redirect()`的区别？

`forward()`仅仅只是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址，`redirect()`则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接，这样，从浏览器的地址栏中可以看到跳转后的链接地址，所以，前者更加高效，在前者可以满足需要时，尽量使用`forward()`方法，并且，这样也有助于隐藏实际的链接，在有些情况下，比如，跳转到一个其他服务器上的资源，则必须使用`sendRedirect()`方法。



### 什么情况下使用`doGet()`和`doPost()`

`JSP`页面中的`FORM`标签里的`method`属性为`get`时调用`doGet()`，为`POST`时使用`doPost()`



### `Request`的主要方法

| 方法名                                 | 描述                                                 |
| -------------------------------------- | ---------------------------------------------------- |
| `setAttribute(String Name,Object obj)` | 在`request`中添加属性，在转发到页面时可以使用        |
| `getAttribute(String Name)`            | 获取`reuqest`中的属性                                |
| `getAttributeNames()`                  | 获取`request`中的所有属性名字的集合                  |
| `getCookies()`                         | 返回客户端所有的`Cookie`对象，结果是一个`Cookie`数组 |
| `getCharacterEncoding()`               | 获取请求中的字符编码格式                             |
| `getContentLength（）`                 | 获取`body`的长度                                     |
| `getHeader(String name)`               | 获取`Http`协议定义的文件头信息                       |
| `getHeaders()`                         | 获取请求头所有的值，结果是一个枚举的实例             |
| `getHeaderNames()`                     | 获取请求头所有的名字，结果是一个枚举的实例           |
| `getInputStream()`                     | 返回请求的输入流，用于获取请求中的数据               |
| `getMethod()`                          | 获取请求的方式是`GET`还是`POST`                      |
| `getParameter(String name)`            | 获取请求中指定参数的值                               |
| `getParameters()`                      | 获取请求中所有参数的名字，结果是一个枚举实例         |
| `getParametervalues()`                 | 获取请求中所有参数的值，结果是一个枚举实例           |
| `getProtocol()`                        | 获取传输数据所依赖的协议名称                         |
| `getQueryString()`                     | 获取查询字符串                                       |
| `getRequestURI()`                      | 获取客户端的地址                                     |
| `getRemoteAddr()`                      | 获取客户端的IP                                       |
| `getRemoteHost()`                      | 获取客户端的名字                                     |
| `getSession()`                         | 获取会话对象                                         |
| `getServerName()`                      | 获取服务器名字                                       |
| `getServletPath()`                     | 获取请求的脚本文件路径                               |
| `getServerPort()`                      | 获取服务器的端口号                                   |
| `removeAttribute()`                    | 删除请求中的一个属性                                 |





### `JSP`有那些内置对象？作用分别是什么？分别有什么方法？

| 对象名称              | 描述               |
| --------------------- | ------------------ |
| `request`             | 请求对象           |
| `response`            | 响应对象           |
| `pageContext`         | 页上下文           |
| `session`             | 会话对象           |
| `application servlet` | 正在执行的内容     |
| `out`                 | 用来传输回应的输出 |
| `config servlet`      | 配置               |
| `page`                | 页对象             |
| `exception`           | 网页异常           |



### `JSP`有哪些动作，作用是什么？

| 动作              | 作用                                                |
| ----------------- | --------------------------------------------------- |
| `jsp:include`     | 在页面被请求时引入一个文件                          |
| `jsp:useBean`     | 寻找或者实例化一个`JavaBean`                        |
| `jsp:setProperty` | 设置某个`JavaBean`的属性                            |
| `jsp:getProperty` | 输出某个`JavaBean`的属性                            |
| `jsp:forward`     | 把请求转到一个新的页面                              |
| `jsp:plugin`      | 根据浏览器类型为`Java`插件生成`OBJECT`或`EMBED`标记 |



### `JSP`和`Servlet`有哪些相同点和不同点，他们之间的联系是什么？

`JSP`是`Servlet`技术的扩展，本质上是`Servlet`的简易方式，更强调引用的外表表达，`jsp`编译后是一个`Servlet`类，`Servlet`和`JSP`最主要的不同点在于，`Servlet`的逻辑是在`Java`文件中，并且完全从表示层中的`HTML`里分离出来，而`JSP`是将`Java`和`HTML`代码组合成一个扩展名为`.jsp`的文件，`JSP`侧重于视图，`Servlet`主要用于控制逻辑。



### `MVC`的各个部分都有哪些技术来实现，如何实现？

`MVC`是`Model-View-Controller`的简写，在`Servlet`中， `Model`代表的是应用的业务逻辑，`View`是应用的表示面，也就是`JSP`页面，`Controller`是提供应用的处理过程控制，一般是一个`Servlet`，通过这种设计模型把应用的逻辑，处理过程和显示逻辑分成不同的组件来实现，这些组件可以进行交互和重用。



### 在`Web`开发中，如何输出一个某种编码的字符串？

```java
public String translate(String str){
    String tempStr = "";
    try{
        tempStr = new String( str.getBytes("IOS-8859-1"),"GBK" );
        tempStr = tempStr.trim();
    }catch(Exception e){
        System.err.println(e.getMessage());
    }
    return tempStr;
}
```







## 数据库

### 数据库的三范式是什么？

第一范式（`INF`）：字段具有原子性，不可再分。所有关系型数据库系统都满足第一范式，数据库表中的字段都是单一属性的，不可再分。

第二范式（`2NF`）：第二范式是在第一范式的基础上建立起来的，既满足第二范式，必须先满足第一范式，第二范式要求数据库表中的每个实例或行必须可以被唯一的区分，通常需要为表加上一个列，以存储各个实例的唯一表示，这个唯一属性列被称为主关键字或主键。第二范式要求实体的属性完全依赖于主关键字，所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系，为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识，简而言之，第二范式就是非主属性非部分依赖于主关键字。

第三范式（`3NF`）：满足第三范式必须满足第二范式，简而言之，第三范式要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。

第三范式的特征:

- 每一列只有一个值。
- 每一行都能区分。
- 每一个表都不包含其他表已经包含的非主关键字信息。



### `Class.forName()`的作用？为什么要用？

按参数中指定的字符串形式的类名去搜索并加载相应的类，如果该类字节码已经被加载过，则返回代表该字节码的`Class`实例对象，否则，按类加载器的委托机制去搜索和加载该类，如果所有的类加载器都无法加载到该类，则会抛出`ClassNotFoundException`。加载完这个`Class`字节码后，接着就可以使用`Class`字节码的`newInstance()`方法去创建该类的对象了。有时候，我们的程序中所有使用的具体类名在设计时无法确定，只有在程序运行时才能确定，这个时候就需要使用`Class.forName`去动态加载该类，这个类名通常是在配置文件中配置的。例如`Spring`的`IOC`容器每次依赖注入的具体类就是这样配置的，`JDBC`的驱动类名通常也是通过配置文件来配置的，以便在产品交付使用后不修改源程序就可以更换驱动类名。



### 数据库连接池的工作机制是什么

连接池的意思顾名思义，就是以池的思想去管理数据库连接，`J2EE`服务器启动时会建立一定数量的连接，并一直维护部少于此数目的连接，客户端程序需要连接时，池驱动程序会返回一个未使用的连接并将其标记为忙，如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建的连接的数量由配置的参数决定，当使用的连接调用完后，池驱动程序将此连接标记为空闲，其他调用就可以使用这个连接。实现方式，返回的`Connection`是原始的`Connection`的代理，代理`Connection`的`close()`方法不是真正关连接，而是把他代理的`Connection`对象返回到连接池中。



### 为什么要用`ORM`？和`JDBC`有什么不一样？

`ORM`是一种思想，就是把对象转变成数据库中的记录，或者把数据库中的记录转换成对象，我们可以使用`JDBC`来实现这种思想，其实，如果我们的项目是严格按照`OOP`的方式编写的话，我们的`JDBC`程序不管是有意还是无意，就已经在实现`ORM`的工作了。

现在有许多`ORM`工具，他们的底层调用`JDBC`来实现了`ORM`工作，我们直接使用这些工具，就省去了直接使用`JDBC`的繁琐细节，提高了开发效率。`MyBatis`是我们在开发中使用较常见的`ORM`框架。







## `XML`

### `XML`有哪些解析技术，区别是什么？

技术：`DOM`，`SAX`，`STAX`等

区别：

- `DOM`:在处理大型文件时其性能下降的非常厉害，这个问题是有`DOM`的树结构所造成的，这种结构占用的内存较多，而且`DOM`必须在解析文件之前把整个文档装入内存，适合对`XML`的随机访问。
- `SAX`：使用事件驱动型的`XML`解析方式，它顺序读取`XML`文件，不需要一次全部装载整个文件，当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发下一个事件，用户通过在其回调事件中写入处理代码来处理`XML`文件，适合对`XML`的顺序访问
- `STAX`：`Streaming API for XML`



### 你在项目中用到了`XML`技术的那些方面，如何实现？

用到了数据存储，信息配置两方面，在做数据交换平台时，将数据源的数据组装成`XML`文件，然后将`XML`文件压缩打包加密后通过网络传输给接收者，接收解密与解压缩后再同`XML`文件还原相关信息进行处理，在做软件配置时，利用`XML`可以很方便的进行，软件的各种配置参数都存储在`XML`文件中。



### `XML`文档定义有几种形式？他们之间有何本质的区别？解析`XML`文档有哪几种方式？

形式：`DTD`，`schema`

区别：`schema`本身是`XML`的，可以被`XML`解析器解析（这也是从`DTD`上发展`schema`的根本目的）

解析技术：`DOM`，`SAX`，`STAX`等









## 设计模式

### `UML`

标准建模语言，用例图，静态图（包括类图，对象图和包图），行为图，交互图（顺序图，合作图），实现图。



### `J2EE`常用的设计模式？说明工厂模式。

总共23种，分为三大类：创建型，结构型，行为型

- 创建型：工厂，工厂方法，抽象工厂，单例等。
- 结构型：包装，适配器，组合，代理等。
- 行为型：观察者，模板，策略等。

工厂模式：该模式是一种经常被用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中的某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作，首先要定义一个基类，该类的子类通过不同的方法实现了基类中的方法，然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例，当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是那一个子类的实例。

`Java`中的23中设计模式

1. `Factory`工厂模式
2. `Builder`建造模式
3. `Factory Method`工厂方法模式
4. `Prototype`原始模型模式
5. `Singleton`单利模式
6. `Facade`门面模式
7. `Adapter`适配器模式
8. `Bridge`桥梁模式
9. `Composite`合成模式
10. `Decorator`装饰模式
11. `Flyweight`享元模式
12. `Proxy`代理模式
13. `Command`命令模式
14. `Interpreter`解释器模式
15. `Visitor`访问者模式
16. `Iterator`迭代子模式
17. `Mediator`调停者模式
18. `Memento`备忘录模式
19. `Observer`观察者模式
20. `State`状态模式
21. `Strategy`策略模式
22. `Template Method`模板方法模式
23. `Chain Of Responsibleity`责任模式



### 开发中都用到了哪些设计模式，用在什么场合？

每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，你可以无数次的使用那些已有的解决方案，无需再重复相同的工作，主要用到了`MVC`的设计模式，用来开发`JSP/Servlet`或者`J2EE`的相关应用。



## `J2EE`部分

### `BS`与`CS`的联系与区别

`CS`是`Client/Server`的缩写，服务器通常采用高性能的`PC`，工作站或小型机，并采用大型数据库系统，客户机需要安装专用的客户端软件。

`BS`是`Brower/Server`的缩写，客户机上只要安装一个浏览器就可以使用，用户界面完全通过`WWW`浏览器实现，一部分事务逻辑在前端实现，关键的事务逻辑在服务端实现，浏览器通过通过`WebServer`同数据库进行数据交互。

区别主要体现在硬件环境不同，对安全的要求不同，程序架构不同，软件重用不同，系统维护不同，处理问题不同，用户接口不同，信息流不同。



### 应用服务器和`WebServer`的区别

应用服务器：`Weblogic`，`Tomcat`，`JBoos`

`WebServer`：`IIS`，`Apache`

`WebServer`是应用服务器中的一个服务



### 应用服务器有哪些？

- `BEA WebLogic Server`

- `IBM WebSphere Application Server`

- `Oracle9i Application Server`
- `JBoos`
- `Tomcat`



### `J2EE`是什么？

`J2EE`是`Sun`公司提出的，多层（`multi-diered`），分布式（`distributed`），基于组件（`component-base`）的企业级应用模型（`enterpriese application model`），在这样一个应用系统中，可按照功能划分为不同的组件，这些组件有可在不同的计算机上，并且处于相应的层次（`tier`）中，所属层次包括客户层（`client tier`）组件，`web`层和组件，`Business`层和组件，企业信息系统（`EIS`）层。一个牛逼的回答：`J2EE`就是增删改查







