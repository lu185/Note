# 葵花宝典

## `Java`基础部分



### 一个`Java`源文件中是否可以包括多个类(不是内部类)？有什么限制？

可以有多个类，但只能有一个 `public` 类，并且 `public` 的类名必须与文件名一致



### `Java`中有没有`goto`

`goto`时`Java`中的保留字，`JVM`并没有对其进行实现



### 说说`&`和`&&`的区别

`&`和`&&`都可以作为 逻辑与 (`and`) 的运算符，当 运算符 的两边的表达式 都为`true`时，整个运算的结果才为`true`，只要有一方为`false`，则整个表达式为`false`

`&&`具有短路的功能，即如果第一个表达式的值为`false`，则不计算第二个表达式，`&`不管第一个表达是的值是`true`或`false`，都会执行第二个表达式

```java
// 使用 && 不会抛出异常
// 使用 & 则会抛出 空指针 异常
if( str!=null && str.equals("") ){ ... }

// 使用 && i的值不会自增
// 使用 & i的值会自增
if( bl && ++i ){ System.out.println(i) }
```



### `switch`语句能否作用在`byte`上，能否作用在`long`上，及`String`上

在`switch(表达式)`中，表达式只能是一个整数表达式或者枚举常量，整数类型可以是`int`基本类型或`Integer`包装类型，因为`byte`，`short`，`char`都可以隐式转换为`int`,所以这些数据类型及包装类型也是可以的，显然`long`和`String`类型都不符合`switch`的语法规定，并且并不能隐式的转换成`int`类型，所有它们并不能作用于`switch`上



### `short number=1`，`number=number+1`有没有错，`number+=1`有没有错

`number=number+1`有错，由于`number+1`运算时会自动的提升表达式的类型，所以结果是`int`类型，再赋值给`short`类型的`number`时，编译器将报告需要强制类型转换的错误

`number+=1`没错，由于`+=`是`Java`语言规定的运算符，`Java`编译器会对其进行特殊的处理，因此可以正确编译



### `char`类型中能不能存储一个中文汉字，为什么？

`char`类型变量使用来存储`Unicode`编码的字符的，`Unicode`编码字符集中包含了中文字符，所以，`char`类型变量中可以存储中文汉字，不过，如果某个特殊的汉字没有被包含在`Unicode`中，那么，这个字符就不能存储在`char`类型中。（`Unicode`编码占用两个字节，所以`char`类型变量也占用两个字节）



### 用最有效率的方法算出 `2*8=?`

最有效率的方法是：`2<<3`          `2<<3 = 2 * 2^3 = 2 * 8`

将一个数左移3位，就相当于这个数乘以2的3次方，那么，一个数乘以8，只需要将这个数左移3位即可，而且`cpu`直接支持位运算，效率最高。



### 使用`final`关键字修饰一个变量时，是引用不变，还是引用的对象不能变

使用`final`关键字修饰一个变量时，是指引用的变量不能变，引用变量指向的对象中的内容是可以改变的

```java
final StringBuffer str = new StringBuffer("hello ");
str.append("world");       // 这个是可以的
str = new StringBuffer("");					// 报错
```



### `==`和`equals`方法究竟有什么区别

`==`操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本数据类型的数据或两个引用变量是否相等，只能用`==`操作符

`equals`方法用于比较两个独立对象的内容是否相同。就好比去比较两个人的长相是否相同，他比较的两个对象是独立的。

```java
// String 中的 equals 方法解析
public boolean equals(Object anObject) {
    
    // 如果当前对象 等于 anObject  返回 true,
    // 即 多个引用指向同一个对象
    if (this == anObject) {
        return true;
    }
    
    // 用来比较的对象是否是个字符串
    if (anObject instanceof String) {
        // 强制类型转换 
        String anotherString = (String)anObject;
        // this 中的 字符串长度
        int n = value.length; 
        
        // 判断两个字符串的长度是否相同
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            
            // 循环每一个字符
            while (n-- != 0) {
                // 每个字符是否相同
                if (v1[i] != v2[i])
                    // 不同返回 false
                    return false;
                i++;
            }
          	// 完全相同返回 true；
            return true;
        }
    }
    return false;
}
```



### 静态变量于实例变量的区别

在语法定义上的区别：静态变量前面要加`static`关键字修饰，而实例变量则不需要

在程序运行时的区别：实例变量属于某个对象的属性，所以必须创建了实例对象，其中的实例变量才会被分配内存空间，才能使用这个实例变量，静态变量不属于某个实例对象，而是属于类，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配内存空间，静态变量就可以被使用了。



### 是否可以从一个`static`的方法中对一个非`static`方法进行调用

不可以，因为非`static`方法是与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而非`static`方法调用时不需要创建对象，可以直接调用，也就是说，当一个`static`方法被调用时，可能还没有创建任何实例对象，如果从一个`static`方法中对非`static`方法发起调用，那么非`static`方法是关联到那个对象上呢，这个逻辑不能成立，所以，不可以从一个`static`的方法中对一个非`static`方法进行调用



### `Integer`和`int`的区别

`int`是`Java`中的八种基本数据类型之一。`Java`为每个原始数据类型提供了封装类，`Integer`是`Java`为`int`提供的封装类。`int`的默认值为0，而`Integer`的默认值为null，即`Integer`可以区分出0和未赋值的状态。`int`则无法表达储未赋值的情况，例如，要表达出没有参加考试的和考试成绩为0的区别，只能使用`Integer`。



### `Math.round(11.5)`等于多少？`Math.round(-11.5)`等于多少？

`Math`类中提供了三个于取整有关的方法：`ceil`向上取整，`floor`向下取整，`round`四舍五入，

`round`的算法是将原来的数加0.5然后向下取整，所以`Math.round(11.5)`等于12,`Math.round(-11.5)`等于11



### `public`，`private`，`protected`，以及不写时的区别

不写时的默认修饰符是`friendly`

| 作用域      | 当前类 | 当前包 | 子孙类 | 其他包 |
| ----------- | :----: | :----: | :----: | :----: |
| `public`    |   √    |   √    |   √    |   √    |
| `protected` |   √    |   √    |   √    |        |
| `friendy`   |   √    |   √    |        |        |
| `private`   |   √    |        |        |        |



### `Overload`和`Override`的区别，`Overload`的方法是否可以改返回值的类型

`Overload`是重载的意思，`Override`是重写的意思

重载表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表的参数类型，参数顺序，参数个数，各不相同

重写表示子类中的方法可以与父类中的某个方法的名称，返回值，参数完全相同，通过子类创建的对象调用这个方法时，将调用子类中定义的这个方法，这相当于把父类中定义的那个完全相同的方法给覆盖了。如果父类的方法是`private`类型，那么子类就不存在覆盖的限制，相当于子类中增加了一个全新的方法



### 构造器`Constructor`是否可以被`Override`

构造器`Constructor`不能被继承，因此不能重写，但是可以被重载



### 接口是否可以继承接口，抽象类是否可以实现接口，抽象类是否可以继承具体类，抽象类中是否可以有`main`方法。

接口可以实现接口，抽象类可以实现接口，抽象类可以继承具体类，抽象类中可以具有`main`方法、



### 写`clone()`方法时，通常都有一行代码，是什么

`clone`有缺省行为，`super.clone()`；因为首先要把父类中的成员复制到位，然后才能复制自己的成员



### 面向对象的特征有哪些方面

面向对象的特征有 封装，抽象，继承，多态等四个主要特征

封装：面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法定义，方法可以访问对象中的属性。封装要把握一个原则：把对同一事物进行操作的方法和相关的方法放在一个类中，把方法和它操作的数据放在同一个类中。

抽象：抽象就是找出一些事物的相似和共性之处，然后将这些事物的归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题无关的那些方面，将注意力集中与当前目标有关的方面。

继承：在定义和实现一个类的时候，可以在一个已经存在的类的基础上来进行，把这个已经存在的类中所定义的内容作为自己的内容，并加入若干的新的内容，或修改原来的方法来满足现在的需求，这就是继承，继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性

多态：父类的引用指向子类的对象



### `Java`中的多态的实现机制是什么

实现的机制靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期间才动态绑定的，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。



### `abstract class`和`interface`的区别

含有`abstract`修饰符的`class`类即为抽象类，抽象类不能创建实例对象，含有`abstract`修饰符的方法必须是抽象类的方法，即抽象方法，抽象类的方法不必是抽象方法，抽象类中的抽象方法必须在具体的子类中实现，所以不能有抽象构造方法和抽象静态方法，如果抽象类的子类没有实现所有的抽象方法，那么，子类也必须定义为抽象类

`interface`接口可以说成是抽象类的一种特例，接口中的所有方法必须是抽象的，接口中的方法默认为`public abstract`类型，接口中的成员变量类型默认为`public static final`。

两者的区别：

1. 抽象类可以有构造方法，接口不能有
2. 抽象类可以有普通的成员变量，接口中不能有
3. 抽象类可以包含非抽象的普通方法，接口中的所有方法必须是抽象的
4. 抽象类的抽象方法的访问修饰符可以是`public` ，`protected`和默认的`friendy`，但接口中的方法只能是`public`类型的，并默认为`public abstract`类型
5. 抽象类中可以有静态方法法，接口不能有
6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的成员变量只能是`public static final`类型，并且默认为`public static final`类型。
7. 一个类可以实现多个接口，但只能继承一个抽象类



### 抽象方法是否可以被`static`修饰，是否可以被`native`修饰，是否可以被`synchronized`修饰

抽象方法不可以被`static`修饰，因为抽象方法是要被子类实现的，而被`static`修饰的方法和子类扯不上关系

`native`修饰的方法表示该方法要依赖其他编程语言实现功能。不存在被子类实现的问题，所以他不能被抽象。

关于`synchronized`与`abstract`合用的问题，我觉得不行，因为在我几年的学习和开发实践中，从来没有见过这种情况，并且我觉得`synhronized`应该是作用在一个具体的方法上才有意义，而且，方法上的`synchronized`同步所使用的同步锁是`this`，而抽象方法上无法确定`this`是什么。



### `String`是最基本的数据类型吗

`Java`的八大基本类型是`byte`,`shot`,`int`,`long`,`float`,`double`,`boolean`,`char`

`String`是个被`final`修饰的类，所以不能被继承，不能被修改，即断子绝孙类。为了提高效率，节省空间，我们应该使用`StringBuffer`类



### `String s="hello ";  s=s+"world"`，原始的`String`对象中的内容到底变了没有

没有。因为`String`被设计成不可变类，所以他的所有对象都是不可变对象。`s`最初指向了值为`hello`的地址，`S`加上`word`后的值为`hello world`，这时`s`这个引用变量的值又指向了`hello world`的地址，所以原来的`String`中的内容没有变，只是`s`指向了新的地址



### 是否可以继承`String`类

不可以，`String` 是一个被`final`修饰的类，不能被继承，修改，即 断子绝孙类



### `String s = new String("xyz");`创建了几个字符串对象，二者的区别

两个。一个是静态区的`"xyz"`，一个是用`new`创建在堆上的对象。



### `String`和`StringBuffer`的区别

`Java`平台提供了两个类`String`和`StringBuffer`，他们可以用来存储和操作字符串，即包含多个字符的字符数据，这个`String`类提供类数值不可改变的字符串，而这个`StringBuffer`类提供了字符串修改，当你知道字符数据需要改变的时候你就可以使用`StringBuffer`来动态构造字符数据，另外，`String`实现了`equals`方法，`new String("abc").equals(new String("abc"));`的结果为`true`,而`StringBuffer`没有实现`equals`方法，所以，`new StringBuffer("abc").equals(new StringBuffer("abc"))`的结果为`false`。



### 数组有没有`length()`方法，`String`有没有`length()`方法

数组没有`length()`方法，有`length`属性，`String`没有`length（）`方法



### `String s = "a"+"b"+"c"+"d"；`一共创建了多少个方法

```java
String s1 = "a";
String s2 = s1+"b";
String s3 = "a"+"b";

System.out.println( s2 == "ab" );     // false
System.out.println( s3 == "ab" );	  // true
```

第一条语句打印的结果为`false`，第二条语句的打印结果为`true`，这说明`Java`编译时可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个常量相连的一个结果。所以对于语句`String s = "a"+"b"+"c"+"d";`来说，最终只创建了一个对象。



### `try{}`里有一个`retrun`,那么紧跟在这个`try`后的`finally{}`里的代码会不会得到执行，什么时候被执行，在`return`前还是后

有如下代码：

```java
public class Test {
    public static void main(String[] args) {
        System.out.println("return "+run());
    }
    static int run(){
        int x = 0;
        try {
            x = 1;
            System.out.println("try "+x);
            return x;
        }finally {
            x++;
            System.out.println("finally "+x);
        }
    }
}
```

结果

```
try 1
finally 2
return 1
```



结果很明显，`finally{}`里的代码会得到执行，代码会在`return`返回之后处理`findally`中的代码。



### 如下程序的运行结果是多少

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(run());
    }
    static int run(){
        try {
            return 1;
        }finally {
            return 2;
        }
    }
}
```

结果为`2`，底层原理:`return`不会立刻让方法返回结果，会把返回的结果放在函数栈中，等到`finally`执行完成之后，才会把真正的结果返回。



### `final`，`finally`，`finalize`的区别

`final`用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。

`finally`是异常处理语句结构的一部分，表示总是执行。

`finalize`是`Object`类中的方法，在垃圾收集器执行的时候要被回收的对象会调用此方法。`JVM`不保证此方法总被调用



### 运行时异常与一般异常有何异同？

异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，`Java`编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。



### `Error`和`Exception`有什么区别

`Error`：表示恢复不是不可能但是很困难的情况下的一种严重问题，比如说内存溢出，不可能指望程序处理这样的情况。

`Exception`：表示一种设计或实现的问题，他表示如果程序运行正常，从不会发生的情况



### `Java`中的异常处理机制的简单原理和应用

异常是指`Java`程序运行时所发生的非正常情况，`Java`使用面向对象的方式来处理异常，它把程序中发生的所有异常分别封装到每一个类中，该类的对象包含异常的信息。

`Java`对异常进行了分类，不同类型的异常用不同的`Java`类来表示，所有异常类的根类是`java.lang.Throwable`，`Throwable`下面又派生出两个子类：`Error`和`Exception`。

`Error`：表示程序本身无法克服和恢复的一种严重问题，程序只有死的份了。例如：内存溢出，线程死锁等问题。

`Exception`：表示程序本身还可以克服和恢复。其中又分为系统异常和普通异常。

- 系统异常：是软件本身的缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，用户无法克服和恢复这种问题，但是在这种问题下还可以让软件系统继续运行或者让软件死掉。例如：数组下标越界，空指针异常，类转换异常。
- 普通异常：是运行环境的变化或异常所导致的问题，是用户可以克服的问题，例如：网络断线，硬盘空间不够，发生这样的异常之后程序不应该死掉。

`Java`为异常提供了不同的解决方案，编译器强制普通异常必须`try{}catch{}`处理或用`throws`声明继续抛给上层调用方法处理，所以普通异常也被称为`checked`异常，而系统异常可以处理也可以不处理，所以不强制使用`try{}catch{}`和`throws`处理，所以系统异常也被称为`unchecked`异常。




### 请写出五个最常见的运行时异常

| 异常                             | 描述             |
| -------------------------------- | ---------------- |
| `NullPointerException`           | 空指针异常       |
| `ClassNotFoundException`         | 类未定义异常     |
| `ArrayIndexOutOfBoundsException` | 数组下标越界异常 |
| `ClassCastException`             | 类转换异常       |
| `ArithmeticException`            | 除数为0异常      |



### `sleep()`和`wait()`的区别

`sleep()`就是让正在执行的线程主动让出`cpu`，`cpu`区执行其他线程，在`sleep()`指定的时间过后，`cpu`才会回到这个线程上继续往下执行，如果当线程进入了同步锁，`sleep()`方法并不会释放锁，即使当前线程使用`sleep()`方法让出了`cpu`，但其他被同步锁挡住了的线程也无法执行。

`wait()`是指在一个已经进入了同步锁的线程内，让自己暂时的让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有当其他线程调用了`notify()`方法(`notify()`方法并不释放锁，只是告诉调用过`wait()`方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没有释放)，调用`wait()`方法的线程就会解除`wait()`状态和程序可以再次得到锁后继续向下运行。



### 同步和异步有何异同，在什么情况下分别使用他们？

如果数据将在线程间共享，例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序让等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。



### 多线程有几种实现方法，同步有几种实现方法

多线程有两种实现方法，分别是继承`Thread`类和实现`Runnable`接口。

同步有两种实现方法，分别是`synchronized`，`wate()`和`notify()`



### 启动一个线程使用`run()`还是`start()`

启动一个线程调用`start()`方法，使线程进入就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，`run()`方法是该线程所关联的执行代码。



### 当一个线程进入一个对象的一个`synchronized`方法后，其他线程是否可进入此对象的其他方法

分情况：

- 其他方法前是否加了`synchronized`关键字，如果没加，则能。
- 如果这个方法内部调用了`wait()`方法，则可以进入其他`synchronized`方法。
- 如果其他方法都加了`shnchronized`关键字，并且内部没有调用`wait()`，则不能。
- 如果其他方法是`static`，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是`this`。



### 线程的基本概念，线程的基本状态以及状态之间的管理

一个程序中可以有多条线程同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，既可以有多段程序代码同时运行，每个程序至少都有一个线程，即`main`方法执行的那个线程。如果只是一个`cpu`，它怎么能够同时执行多段程序呢？这是从宏观上来看的，`cpu`一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a，b在同时执行。

线程的状态：就绪，运行，`synchronize`阻塞，`wate()`和`sleep()`挂起，结束。( `wate()`必须在`synchronize`内部调用 )

调用线程的`start()`方法后，线程进入就绪状态，线程调度系统将就绪状态的线程转换为运行状态，遇到`synchronize`语句时，由运行状态转换为阻塞状态，当`synchronize`获得锁后，由阻塞状态转为运行状态，在这种情况下可以调用`wait()`方法转换为挂起状态，当线程关联的代码执行完成后，线程变为结束状态。



### 简述`synchronized`和`java.util.concurrent.locks.Lock`的异同

相同点：`Lock`能完成`synchronized`所实现的所有功能。

不同点：`Lock`有比`synchronized`更精确的线程语义和更好的性能。`synchronized`会自动释放锁，而`Lock`要手动释放，并且必须在`finally`语句块中释放，`Lock`还有更强大的功能，例如，它的`tryLock()`方法可以用非阻塞的方式去拿锁。



### 介绍`Collection`框架的结构



### `Collection`框架中完成比较功能要实现什么接口

`comparable`/`comparator`



### `ArrayList`和`Vector`的区别

它们都实现了`List`接口(`List`接口继承于`Collection`接口)，他们都是有序集合，即：存储在这两个集合中的元素都是有顺序的，相当于是一种动态数组，可以按照下标取出相应的元素，并且元素是允许重复的。区别：

同步性：`Vector`的线程是安全的，即它的方法之间的线程是同步的，而`ArrayList`的线程是不安全的，他的方法之间的线程是不同步的。如果只有一个线程会访问到集合，那最好是使用`ArrayList`，因为它不考虑线程安全，效率会高些，如果有多个线程会访问到集合，那最好使用`Vector`，因为不需要我们再去考虑和编写线程安全的代码。

数据增长：`ArrayList`与`Vector`都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加`ArrayList`和`Vector`的存储空间，每次要增加存储空间时，不是只增加了一个存储单元，而是增加了多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡，`Vector`默认增长的为原来的两倍，而`ArrayList`的增长策略在文档中没有明确的规定（从源代码中解读到的是增长为原来的1.5倍），`ArrayList`与`Vector`都可以设置初始的空间大小，`Vector`还可以设置增长的空间，而`ArrayList`没有设置可以增长空间的方法。



### `HashMap`和`Hashtable`的区别

`HashMap`是`Hashtable`的轻量级实现，他们都完成了`Map`的接口，主要区别在于`HashMap`允许`Key`为空，由于非线程安全，在只有一个线程访问的情况下效率要高于`Hashtable`。

`HashMap`把`Hashtable`的`contains`方法去掉了，改成了`containsKey`和`containsValue`，因为`contains`方法容易让人误解。

`Hashtable`继承自`Dictionary`类，而`HashMap`是`Java1.2`引进的`Map`接口的一个实现。最大的不同是，`Hashtable`的方法是线程是安全的，而`HashMap`不是，在多个线程访问`Hashtable`时，不需要自己为它的方法实现同步，而`HashMap`的就必须方法同步。

`Hashtable`和`HashMap`采用的`hash\rehash`算法大概都一样，所以性能不会有很大的差异。

就`HashMap`和`Hashtable`主要从三方面来说：

1. 历史原因：`Hashtable`是基于陈旧的`Dictionary`类的，`HashMap`是`Java1.2`引进的Map接口的一个实现
2. 同步性：`Hashtable`是线程安全的，是同步的，而`HashMap`是线程不安全的，是不同步的。
3. 值：`HashMap`可以将空值作用为`key`或`value`



### `List`和`Map`的区别

一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，`List`中存储的数据是有序的，并且允许重复，`Map`中存储的数据是没有顺序的，其键是不能重复的，它的值是可以允许重复的。



### `List`，`Set`，`Map`是否继承自`Collection`接口

`List`，`Set`是，`Map`不是



### `List`，`Map`，`Set`三个接口存储数据时，各有什么特点

首先，`List`与`Set`具有相似性，它们都是单列元素的集合，所以他们都有一个共同的父接口，叫`Collection`，`Set`里面不允许有重复的元素，会对数据进行排序，`Set`的`add()`方法有一个`boolean`的返回值，当集合中没有某个元素时，此时`add()`方法可以成功的加入该元素，返回值为`true`，当集合含有某个元素时，此时`add()`方法无法加入该元素，返回值为`false`，`Set`取元素时，没法说取第几个，只能以`Iterator`接口取得所有的元素，再逐一遍历各个元素。

`List`表示有先后顺序的集合，当调用`add()`方法的时候，元素会依次往后添加，也可以在`add()`中指定下标，就可以指定当前元素在集合中的位置，一个对象可以反复存储进集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被多次添加时，即相当于集合中有多个索引指向了这个对象，`List`除了可以以`Iterator`接口取得所有的元素，再逐一遍历各个元素之外，还可以调用`get()`方法来说明取第几个。

`Map`与`List`和`Set`不同，他是双列的集合，其中有`put()`方法，每次存储时要存储一对`key/value`，不能存储重复的`key`，会将之前的覆盖掉，取值则是根据`key`获得相应的`value`，即使用`get()`方法获取`value`值，另外，也可以获取所有`value`的集合，还可以获取`key`和`value`组合成的`Map.entity`对象的集合。

`List`以特定次序来持有元素，可以重复元素。`Set`无法拥有重复元素，内部排序。`Map`保存`key-value`值，`value`可多值。

`HashSet`按照`HashCode`值的某种运算方式进行存储，而不是直接按照`HashCode`值的大小进行存储。

同一个对象可以在`Vector`中加入多次，往集合里添加元素，相当于集合里用一根绳子连接到了目标对象，往`HashSet`中却添加不了多次。



### 说说`ArrayList`，`Vector`，`LinkedList`的存储性能和特性

`ArrayList`和`Vector`都是使用数组的方式存储数据，此数组元素数大于实际存储的数据以便增加和存储的元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据块而插入数据慢，`Vector`由于使用了`synchronized`方法（线程安全），通常性能上比`ArrayList`差，`LinkedList`使用了双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据是只需要记录本项的前后项即可，所以插入速度比较块。



### 去掉一个`Vector`集合中的元素

```java
Vector vector = new Vector();
// add Data;
HashSet set = new HashSet(vector);
```



### `Collection`和`Collections`的区别

`Collection`是集合类的上级接口，继承与他的接口主要有`Set`和`List`

`Collecctions`是针对集合类的一个帮助类，它提供一系列静态方法实现对各种集合的搜索，排序，线程安全化的操作。



### `Set`里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用`==`还是`equals()`？他们有何区别？

`Set`里的元素时不能重复的，元素重复与否是使用`equals()`方法进行判断的。`equals()`和`==`决定引用值是否指向同一对象，`equals()`在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回其值。



### 你所知道的集合类有哪些？主要方法？

最常用的集合类是`List`和`Map`，`List`的具体实现包括`ArrayList`和`Vector`，它们是可变大小的列表，比较适合构建，存储和操作任何类型对象的元素列表。`List`适用于按数值索引访问元素的情形。`Map`提供了一个更通用的元素存储方法。`Map`集合类采用键值对的方式存储数据。

| 类            | 方法                     |
| ------------- | ------------------------ |
| `List`，`Set` | `add()`添加，`get()`获取 |
| `Map`         | `put()`添加              |



### 两个对象值相同，但却可以有不同的`HashCode`，这句话对不对？

对。如果对象要保存在`HashSet`或`HashMap`中，它们的`equals`相等，那么，它们的`HashCode`值必须相等。

如果不是要保存在`HashSet`或`HashMap`，则与`HashCode`没有什么关系了，这时候`HashCode`不等是可以的，例如`ArrayList`存储的对象就不用实现`HashCode`，当然，我们没有理由不实现，通常都会去实现的。



### `ThreeSet`里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的`compareTo`方法，还是使用的子类的`compareTo`方法，还是抛异常

应该是没有针对问题的确切的答案，当前的add方法放入的是那个对象，就调用哪个对象的`compareTo`方法，至于这个`compareTo`方法怎么做，就看当前这个对象的类中是如何编写这个方法的。







