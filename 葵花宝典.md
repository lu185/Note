# 葵花宝典

## `Java`基础部分



### 一个`Java`源文件中是否可以包括多个类(不是内部类)？有什么限制？

可以有多个类，但只能有一个 `public` 类，并且 `public` 的类名必须与文件名一致



### `Java`中有没有`goto`

`goto`时`Java`中的保留字，`JVM`并没有对其进行实现



### 说说`&`和`&&`的区别

`&`和`&&`都可以作为 逻辑与 (`and`) 的运算符，当 运算符 的两边的表达式 都为`true`时，整个运算的结果才为`true`，只要有一方为`false`，则整个表达式为`false`

`&&`具有短路的功能，即如果第一个表达式的值为`false`，则不计算第二个表达式，`&`不管第一个表达是的值是`true`或`false`，都会执行第二个表达式

```java
// 使用 && 不会抛出异常
// 使用 & 则会抛出 空指针 异常
if( str!=null && str.equals("") ){ ... }

// 使用 && i的值不会自增
// 使用 & i的值会自增
if( bl && ++i ){ System.out.println(i) }
```



### `switch`语句能否作用在`byte`上，能否作用在`long`上，及`String`上

在`switch(表达式)`中，表达式只能是一个整数表达式或者枚举常量，整数类型可以是`int`基本类型或`Integer`包装类型，因为`byte`，`short`，`char`都可以隐式转换为`int`,所以这些数据类型及包装类型也是可以的，显然`long`和`String`类型都不符合`switch`的语法规定，并且并不能隐式的转换成`int`类型，所有它们并不能作用于`switch`上



### `short number=1`，`number=number+1`有没有错，`number+=1`有没有错

`number=number+1`有错，由于`number+1`运算时会自动的提升表达式的类型，所以结果是`int`类型，再赋值给`short`类型的`number`时，编译器将报告需要强制类型转换的错误

`number+=1`没错，由于`+=`是`Java`语言规定的运算符，`Java`编译器会对其进行特殊的处理，因此可以正确编译



### `char`类型中能不能存储一个中文汉字，为什么？

`char`类型变量使用来存储`Unicode`编码的字符的，`Unicode`编码字符集中包含了中文字符，所以，`char`类型变量中可以存储中文汉字，不过，如果某个特殊的汉字没有被包含在`Unicode`中，那么，这个字符就不能存储在`char`类型中。（`Unicode`编码占用两个字节，所以`char`类型变量也占用两个字节）



### 用最有效率的方法算出 `2*8=?`

最有效率的方法是：`2<<3`          `2<<3 = 2 * 2^3 = 2 * 8`

将一个数左移3位，就相当于这个数乘以2的3次方，那么，一个数乘以8，只需要将这个数左移3位即可，而且`cpu`直接支持位运算，效率最高。



### 使用`final`关键字修饰一个变量时，是引用不变，还是引用的对象不能变

使用`final`关键字修饰一个变量时，是指引用的变量不能变，引用变量指向的对象中的内容是可以改变的

```java
final StringBuffer str = new StringBuffer("hello ");
str.append("world");       // 这个是可以的
str = new StringBuffer("");					// 报错
```



### `==`和`equals`方法究竟有什么区别

`==`操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本数据类型的数据或两个引用变量是否相等，只能用`==`操作符

`equals`方法用于比较两个独立对象的内容是否相同。就好比去比较两个人的长相是否相同，他比较的两个对象是独立的。

```java
// String 中的 equals 方法解析
public boolean equals(Object anObject) {
    
    // 如果当前对象 等于 anObject  返回 true,
    // 即 多个引用指向同一个对象
    if (this == anObject) {
        return true;
    }
    
    // 用来比较的对象是否是个字符串
    if (anObject instanceof String) {
        // 强制类型转换 
        String anotherString = (String)anObject;
        // this 中的 字符串长度
        int n = value.length; 
        
        // 判断两个字符串的长度是否相同
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            
            // 循环每一个字符
            while (n-- != 0) {
                // 每个字符是否相同
                if (v1[i] != v2[i])
                    // 不同返回 false
                    return false;
                i++;
            }
          	// 完全相同返回 true；
            return true;
        }
    }
    return false;
}
```



### 静态变量于实例变量的区别

在语法定义上的区别：静态变量前面要加`static`关键字修饰，而实例变量则不需要

在程序运行时的区别：实例变量属于某个对象的属性，所以必须创建了实例对象，其中的实例变量才会被分配内存空间，才能使用这个实例变量，静态变量不属于某个实例对象，而是属于类，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配内存空间，静态变量就可以被使用了。



### 是否可以从一个`static`的方法中对一个非`static`方法进行调用

不可以，因为非`static`方法是与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而非`static`方法调用时不需要创建对象，可以直接调用，也就是说，当一个`static`方法被调用时，可能还没有创建任何实例对象，如果从一个`static`方法中对非`static`方法发起调用，那么非`static`方法是关联到那个对象上呢，这个逻辑不能成立，所以，不可以从一个`static`的方法中对一个非`static`方法进行调用



### `Integer`和`int`的区别

`int`是`Java`中的八种基本数据类型之一。`Java`为每个原始数据类型提供了封装类，`Integer`是`Java`为`int`提供的封装类。`int`的默认值为0，而`Integer`的默认值为null，即`Integer`可以区分出0和未赋值的状态。`int`则无法表达储未赋值的情况，例如，要表达出没有参加考试的和考试成绩为0的区别，只能使用`Integer`。



### `Math.round(11.5)`等于多少？`Math.round(-11.5)`等于多少？

`Math`类中提供了三个于取整有关的方法：`ceil`向上取整，`floor`向下取整，`round`四舍五入，

`round`的算法是将原来的数加0.5然后向下取整，所以`Math.round(11.5)`等于12,`Math.round(-11.5)`等于11



### `public`，`private`，`protected`，以及不写时的区别

不写时的默认修饰符是`friendly`

| 作用域      | 当前类 | 当前包 | 子孙类 | 其他包 |
| ----------- | :----: | :----: | :----: | :----: |
| `public`    |   √    |   √    |   √    |   √    |
| `protected` |   √    |   √    |   √    |        |
| `friendy`   |   √    |   √    |        |        |
| `private`   |   √    |        |        |        |



### `Overload`和`Override`的区别，`Overload`的方法是否可以改返回值的类型

`Overload`是重载的意思，`Override`是重写的意思

重载表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表的参数类型，参数顺序，参数个数，各不相同

重写表示子类中的方法可以与父类中的某个方法的名称，返回值，参数完全相同，通过子类创建的对象调用这个方法时，将调用子类中定义的这个方法，这相当于把父类中定义的那个完全相同的方法给覆盖了。如果父类的方法是`private`类型，那么子类就不存在覆盖的限制，相当于子类中增加了一个全新的方法



### 构造器`Constructor`是否可以被`Override`

构造器`Constructor`不能被继承，因此不能重写，但是可以被重载



### 接口是否可以继承接口，抽象类是否可以实现接口，抽象类是否可以继承具体类，抽象类中是否可以有`main`方法。

接口可以实现接口，抽象类可以实现接口，抽象类可以继承具体类，抽象类中可以具有`main`方法、



### 写`clone()`方法时，通常都有一行代码，是什么

`clone`有缺省行为，`super.clone()`；因为首先要把父类中的成员复制到位，然后才能复制自己的成员



### 面向对象的特征有哪些方面

面向对象的特征有 封装，抽象，继承，多态等四个主要特征

封装：面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法定义，方法可以访问对象中的属性。封装要把握一个原则：把对同一事物进行操作的方法和相关的方法放在一个类中，把方法和它操作的数据放在同一个类中。

抽象：抽象就是找出一些事物的相似和共性之处，然后将这些事物的归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题无关的那些方面，将注意力集中与当前目标有关的方面。

继承：在定义和实现一个类的时候，可以在一个已经存在的类的基础上来进行，把这个已经存在的类中所定义的内容作为自己的内容，并加入若干的新的内容，或修改原来的方法来满足现在的需求，这就是继承，继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性

多态：父类的引用指向子类的对象



### `Java`中的多态的实现机制是什么

实现的机制靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期间才动态绑定的，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。



### `abstract class`和`interface`的区别

含有`abstract`修饰符的`class`类即为抽象类，抽象类不能创建实例对象，含有`abstract`修饰符的方法必须是抽象类的方法，即抽象方法，抽象类的方法不必是`abstarct`修饰的方法，抽象类中的抽象方法必须在具体的子类中实现，所以不能有抽象构造方法和抽象静态方法，如果抽象类的子类没有实现所有的抽象方法，那么，子类也必须定义为抽象类

`interface`接口可以说成是抽象类的一种特例，接口中的所有方法必须是抽象的，接口中的方法默认为`public abstract`类型，接口中的成员变量类型默认为`public static final`。

两者的区别：

1. 抽象类可以有构造方法，接口不能有
2. 抽象类可以有普通的成员变量，接口中不能有
3. 抽象类可以包含非抽象的普通方法，接口中的所有方法必须是抽象的
4. 抽象类的抽象方法的访问修饰符可以是`public` ，`protected`和默认的`friendy`，但接口中的方法只能是`public`类型的，并默认为`public abstract`类型
5. 抽象类中可以有静态法法，接口不能有
6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的成员变量只能是`public static final`类型，并且默认为`public static final`类型。
7. 一个类可以实现多个接口，但只能继承一个抽象类



### 抽象方法是否可以被`static`修饰，是否可以被`native`修饰，是否可以被`synchronized`修饰

抽象方法不可以被`static`修饰，因为抽象方法是要被子类实现的，而被`static`修饰的方法和子类扯不上关系

`native`修饰的方法表示该方法要依赖其他编程语言实现功能。不存在被子类实现的问题，所以他不能被抽象。

关于`synchronized`与`abstract`合用的问题，我觉得不行，因为在我几年的学习和开发实践中，从来没有见过这种情况，并且我觉得`synhronized`应该是作用在一个具体的方法上才有意义，而且，方法上的`synchronized`同步所使用的同步锁是`this`，而抽象方法上无法确定`this`是什么。



### `String`是最基本的数据类型吗

`Java`的八大基本类型是`byte`,`shot`,`int`,`long`,`float`,`double`,`boolean`,`char`

`String`是个被`final`修饰的类，所以不能被继承，不能被修改，即断子绝孙类。为了提高效率，节省空间，我们应该使用`StringBuffer`类



### `String s="hello ";  s=s+"world"`，原始的`String`对象中的内容到底变了没有

没有。因为`String`被设计成不可变类，所以他的所有对象都是不可变对象。`s`最初指向了值为`hello`的地址，`S`加上`word`后的值为`hello world`，这时`s`这个引用变量的值又指向了`hello world`的地址，所以原来的`String`中的内容没有变，只是`s`指向了新的地址



### 是否可以继承`String`类

不可以，`String` 是一个被`final`修饰的类，不能被继承，修改，即 断子绝孙类



### `String s = new String("xyz");`创建了几个字符串对象，二者的区别

两个。一个是静态区的`"xyz"`，一个是用`new`创建在堆上的对象。



### `String`和`StringBuffer`的区别

`Java`平台提供了两个类`String`和`StringBuffer`，他们可以用来存储和操作字符串，即包含多个字符的字符数据，这个`String`类提供类数值不可改变的字符串，而这个`StringBuffer`类提供了字符串修改，当你知道字符数据需要改变的时候你就可以使用`StringBuffer`来动态构造字符数据，另外，`String`实现了`equals`方法，`new String("abc").equals(new String("abc"));`的结果为`true`,而`StringBuffer`没有实现`equals`方法，所以，`new StringBuffer("abc").equals(new StringBuffer("abc"))`的结果为`false`。























